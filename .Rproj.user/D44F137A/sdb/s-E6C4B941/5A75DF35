{
    "collab_server" : "",
    "contents" : "\n\n##################################################################################\n##\n## Main R function written by Satoshi Morita\n## Downloaded 12/12/17 via https://biostatistics.mdanderson.org/softwaredownload/\n##\n##################################################################################\n\n#***************************************************************************\n#        R code for determining the Effective Sample Size (ESS)\n#        of a logistic or linear regression model\n#                 Version 1.0,  11Aug2009\n#***************************************************************************\n\n\n#For the example input data shown here:\n#This normal linear regression example\n#            should calculate the ESS  of 2 for the whole vector (theta0,theta_1,theta_2,theta_3,tau),\n#                             the ESS1 of 2 for the subvector 1 (theta0,theta_1,theta_2,theta_3), and\n#                             the ESS2 of 2 for the subvector 2 (tau).\n\n\n\n## Notes on a regression model ##\n## Let theta_j for j=0,...,d be a parameter for a regression model.\n## Let theta_0 be a parameter for an intercept.\n## Let theta_1,..., theta_d be parameters for regression coefficients of covariates X_1,..., X_d.\n## Thus, a linear term of a selected regression model is given as theta_0 + X_1*theta_1 + ... + X_d*theta_d.\n\n\n##### Please input the follwoing information at Steps 1 to 5 #####\n\n## Step 1. Specify a regression model by imputing 1 or 2:\n## 1 for a linear regression model, --> SEE Note (2) below\n## 2 for a logistic regression model.\n\n#  Reg_model <- 1\n\n## Step 2. Specify the number of covariates (up to 10, 1<=d<=10):\n\n#  Num_cov <- 3\n\n## Step 3. Specify a prior distribution function for each theta by imputing 1 or 2,\n## 1 for a normal N(mu,s2) with mean mu and variance s2,\n## 2 for a gamma Ga(a,b) with mean a/b and variance a/(b*b)\n## and give the numerical values of your hyperparameters:\n##  For example, you assume that theta_0 follows N(0,1000), please input as \"Prior_0 <- c(1, 0, 1000)\".\n## Note(1): If, for example, the number of covariates is set at 5, please just ignore the entries for\n##              theta_6,..,theta_10.\n##          Those numerical values do not affect the ESS computations.\n## Note(2): Please specify a gamma prior for the precision parameter tau using the final line\n##          following those for the covariates.\n##          For example, the number of covariates is 5, please specify the prior using \"Prior_6\" as\n##            \"Prior_6 <- c(2, 0.001, 0.001)\".\n\n#  Prior_0 <- c(1, 0,    1)    # for theta_0\n#  Prior_1 <- c(1, 0,    1)    # for theta_1\n#  Prior_2 <- c(1, 0,    1)    # for theta_2\n#  Prior_3 <- c(1, 0,    1)    # for theta_3\n#  Prior_4 <- c(2, 1,    1)    # for theta_4\n#  Prior_5 <- c(1, 0, 1000)    # for theta_5\n#  Prior_6 <- c(1, 0, 1000)    # for theta_6\n#  Prior_7 <- c(1, 0, 1000)    # for theta_7\n#  Prior_8 <- c(1, 0, 1000)    # for theta_8\n#  Prior_9 <- c(1, 0, 1000)    # for theta_9\n#  Prior_10<- c(1, 0, 1000)    # for theta_10\n#  Prior_11<- c(1, 0, 1000)    # for theta_11\n\n## Step 4. Set M being a positive integer chosen so that, initially, it is reasonable to assume the prior ESS <= M.\n## If M is not sufficiently large, 'NA' returns as a result of the computations.\n\n#  M <- 10\n\n## Step 5. Specify the number of simulations. A suggested value is 5000.\n# The user can use NumSims = 10,000 to carry out the most accurate ESS computations.\n# The value of NumSims as low at 1,000 may be used to reduce runtime.\n\n# NumSims <- 5000\n\n\n\n## Step 6. If you would like to compute ESS of a subvector of (theta_0,...,theta_11),\n##         please input \"1\" in the corresponding elements in the following indicator vectors.\n##         This program can compute ESSs of two subvectors of theta at the same time.\n##         If you are interested in three or more subvectors, please repeat the computations\n##         with different indicator vectors.\n##  For example, if you are interested in the first three parameters, theta_0, theta_1, and theta_2,\n##  please input 1's as c(    1,     1,     1,     0,     0,     0,     0,     0,     0,     0,     0,     0)\n\n##                theta0,theta1,theta2,theta3,theta4,theta5,theta6,theta7,theta8,theta9,theta10,theta11\n#  theta_sub1 <- c(    1,     1,     1,     1,     0,     0,     0,     0,     0,     0,     0,     0)\n#  theta_sub2 <- c(    0,     0,     0,     0,     1,     0,     0,     0,     0,     0,     0,     0)\n\n\n#########################################################################################################\n###########      End of sample input information.                                               #########\n#########################################################################################################\n\n\n\n\n#########################################################################################################\n###########      The code below performs the actual Regression Calculation.                     #########\n#########################################################################################################\n\nESS_RegressionCalc <- function( Reg_model, Num_cov,\n                                Prior_0, Prior_1, Prior_2, Prior_3, Prior_4, Prior_5,\n                                Prior_6, Prior_7, Prior_8, Prior_9, Prior_10, Prior_11,\n                                M, NumSims,\n                                theta_sub1, theta_sub2\n)\n{\n\n  ##### Start computing #####\n\n  # Specify the prior means and Dp values under the priors and the Dq0 values under the epsilon-information priors.\n  Prior  <- rbind(Prior_0,Prior_1,Prior_2,Prior_3,Prior_4,Prior_5,Prior_6,Prior_7,Prior_8,Prior_9,Prior_10,Prior_11)\n  p_mn   <- numeric(1)\n  Dp     <- numeric(1)\n  Dq0    <- numeric(1)\n  c      <- 10000\n  for (j in 1:12){\n    if (Prior[j,1] == 1){\n      p_mn.s <-  Prior[j,2]\n      Dp.s   <-  Prior[j,3]^(-1)\n      Dq0.s  <- (Prior[j,3]*c)^(-1)\n    }\n    if (Prior[j,1] == 2){\n      p_mn.s <-  Prior[j,2]/Prior[j,3]\n      Dp.s   <- (Prior[j,2]  -1)/p_mn.s^2\n      Dq0.s  <- (Prior[j,2]/c-1)/p_mn.s^2\n    }\n    p_mn <- rbind(p_mn,p_mn.s)\n    Dp   <- rbind(Dp  ,Dp.s  )\n    Dq0  <- rbind(Dq0 ,Dq0.s )\n  }\n  p_mn <- p_mn[2:13]\n  Dp   <-   Dp[2:13]\n  Dq0  <-  Dq0[2:13]\n\n  th_ind <- numeric(12)\n  dim_th1 <- Num_cov+2\n  dim_th2 <- Num_cov+1\n  if (Reg_model == 1){\n    for (j in 1:dim_th1){\n      th_ind[j] <- 1\n    }\n  }\n  if (Reg_model == 2){\n    for (j in 1:dim_th2){\n      th_ind[j] <- 1\n    }\n  }\n  cov_ind    <- numeric(11)\n  dim_linear <- Num_cov+1\n  for (j in 1:dim_linear){\n    cov_ind[j] <- 1\n  }\n\n  # Compute sum_Dp, the trace of the information matrix of the prior p\n  sum_Dp     <- sum(Dp*th_ind)\n  sum_Dp.s1  <- sum(Dp*th_ind*theta_sub1)\n  sum_Dp.s2  <- sum(Dp*th_ind*theta_sub2)\n\n  # Compute sum_Dq0, the trace of the information matrix of the epsilon-information prior q0\n  sum_Dq0    <- sum(Dq0*th_ind)\n  sum_Dq0.s1 <- sum(Dq0*th_ind*theta_sub1)\n  sum_Dq0.s2 <- sum(Dq0*th_ind*theta_sub2)\n\n  # Simulate Monte Carlo samples Y from f(Y)\n  DqYMrep.out    <- numeric(M+1)\n  DqYMrep.out.s1 <- numeric(M+1)\n  DqYMrep.out.s2 <- numeric(M+1)\n  for (t in 1:NumSims)\n  {\n    DqYm.out    <- numeric(M)\n    DqYm.out.s1 <- numeric(M)\n    DqYm.out.s2 <- numeric(M)\n    DqY         <- numeric(1)\n    DqY.s1      <- numeric(1)\n    DqY.s2      <- numeric(1)\n    for (i in 1:M) {\n      # Simulate Monte Carlo samples X from Unif(-1,+1)\n      # If you would like, you can modify the upper and lower limits of the distributions.\n      X1  <- runif(1,min=-1,max=+1)\n      X2  <- runif(1,min=-1,max=+1)\n      X3  <- runif(1,min=-1,max=+1)\n      X4  <- runif(1,min=-1,max=+1)\n      X5  <- runif(1,min=-1,max=+1)\n      X6  <- runif(1,min=-1,max=+1)\n      X7  <- runif(1,min=-1,max=+1)\n      X8  <- runif(1,min=-1,max=+1)\n      X9  <- runif(1,min=-1,max=+1)\n      X10 <- runif(1,min=-1,max=+1)\n      X   <- c(1,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10)*cov_ind\n\n      if (Reg_model == 1){\n        Dq.lin <- X*X*p_mn[Num_cov+2]\n        Dq.all <- numeric(12)\n        Dq.all[1:dim_th1] <- c(Dq.lin[1:dim_linear],p_mn[Num_cov+2]^(-2)/2)\n        Dq     <- sum(Dq.all)\n        Dq.s1  <- sum(Dq.all*theta_sub1)\n        Dq.s2  <- sum(Dq.all*theta_sub2)\n      }\n      if (Reg_model == 2){\n        pi     <- exp(sum(p_mn[1:11]*X))/(1+exp(sum(p_mn[1:11]*X)))\n        pi_pi2 <- pi - pi^2\n        Dq     <- sum(X*X*(pi-pi^2))\n        Dq.s1  <- sum(X*X*(pi-pi^2)*theta_sub1[1:11])\n        Dq.s2  <- sum(X*X*(pi-pi^2)*theta_sub2[1:11])\n      }\n      DqY            <- DqY        + Dq\n      DqY.s1         <- DqY.s1     + Dq.s1\n      DqY.s2         <- DqY.s2     + Dq.s2\n      DqYm.out[i]    <- sum_Dq0    + DqY\n      DqYm.out.s1[i] <- sum_Dq0.s1 + DqY.s1\n      DqYm.out.s2[i] <- sum_Dq0.s2 + DqY.s2\n    }\n    DqYm.out       <- c(sum_Dq0, DqYm.out)\n    DqYm.out.s1    <- c(sum_Dq0.s1, DqYm.out.s1)\n    DqYm.out.s2    <- c(sum_Dq0.s2, DqYm.out.s2)\n    DqYMrep.out    <- rbind(DqYMrep.out,DqYm.out)\n    DqYMrep.out.s1 <- rbind(DqYMrep.out.s1,DqYm.out.s1)\n    DqYMrep.out.s2 <- rbind(DqYMrep.out.s2,DqYm.out.s2)\n  }\n  T1  <- NumSims+1\n  DqYMrep.out    <- DqYMrep.out[c(2:T1),]\n  DqYMrep.out.s1 <- DqYMrep.out.s1[c(2:T1),]\n  DqYMrep.out.s2 <- DqYMrep.out.s2[c(2:T1),]\n  Dqm.out        <- numeric(M+1)\n  Dqm.out.s1     <- numeric(M+1)\n  Dqm.out.s2     <- numeric(M+1)\n  M1  <- M+1\n  for (i in 1:M1) {\n    Dqm.out[i]    <- mean(DqYMrep.out[,i])\n    Dqm.out.s1[i] <- mean(DqYMrep.out.s1[,i])\n    Dqm.out.s2[i] <- mean(DqYMrep.out.s2[,i])\n  }\n\n  # Compute the ESS of the whole theta.\n  D.m     <- Dqm.out - sum_Dp\n  D.min.n <- which(abs(D.m) == min(abs(D.m)))\n  D.min.v <- D.m[which(abs(D.m) == min(abs(D.m)))]\n  {\n    if (D.min.v < 0)       {\n      D.min.v.nxt <- D.m[D.min.n+1]\n      ESS <- D.min.n - 1 + (-D.min.v / (-D.min.v + D.min.v.nxt))\n    }\n    else if (D.min.v > 0)  {\n      D.min.v.prv <- D.m[D.min.n-1]\n      ESS <- D.min.n - 1 - (D.min.v / (D.min.v - D.min.v.prv))\n    }\n    else if (D.min.v == 0) {\n      ESS <- D.min.n -1\n    }\n  }\n  # Compute the ESS.1 of subvector 1 of theta.\n  D.m.s1     <- Dqm.out.s1 - sum_Dp.s1\n  D.min.n.s1 <- which(abs(D.m.s1) == min(abs(D.m.s1)))\n  D.min.v.s1 <- D.m.s1[which(abs(D.m.s1) == min(abs(D.m.s1)))]\n  {\n    if (D.min.v.s1 < 0)       {\n      D.min.v.nxt.s1 <- D.m.s1[D.min.n.s1+1]\n      ESS.s1 <- D.min.n.s1 - 1 + (-D.min.v.s1 / (-D.min.v.s1 + D.min.v.nxt.s1))\n    }\n    else if (D.min.v.s1 > 0)  {\n      D.min.v.prv.s1 <- D.m.s1[D.min.n.s1-1]\n      ESS.s1 <- D.min.n.s1 - 1 - (D.min.v.s1 / (D.min.v.s1 - D.min.v.prv.s1))\n    }\n    else if (D.min.v.s1 == 0) {\n      ESS.s1 <- D.min.n.s1 -1\n    }\n  }\n  # Compute the ESS.2 of subvector 2 of theta.\n  D.m.s2     <- Dqm.out.s2 - sum_Dp.s2\n  D.min.n.s2 <- which(abs(D.m.s2) == min(abs(D.m.s2)))\n  D.min.v.s2 <- D.m.s2[which(abs(D.m.s2) == min(abs(D.m.s2)))]\n  {\n    if (D.min.v.s2 < 0)       {\n      D.min.v.nxt.s2 <- D.m.s2[D.min.n.s2+1]\n      ESS.s2 <- D.min.n.s2 - 1 + (-D.min.v.s2 / (-D.min.v.s2 + D.min.v.nxt.s2))\n    }\n    else if (D.min.v.s2 > 0)  {\n      D.min.v.prv.s2 <- D.m.s2[D.min.n.s2-1]\n      ESS.s2 <- D.min.n.s2 - 1 - (D.min.v.s2 / (D.min.v.s2 - D.min.v.prv.s2))\n    }\n    else if (D.min.v.s2 == 0) {\n      ESS.s2 <- D.min.n.s2 -1\n    }\n  }\n\n  ### The prior ESS of the whole theta is  ESS\n\n  ### The prior ESS of subvector 1     is  ESS.s1\n\n  ### The prior ESS of subvector 2     is  ESS.s2\n  return( list(ESSwholetheta=ESS, ESSsubvector1=ESS.s1, ESSsubvector2=ESS.s2) )\n\n\n}  # end of ESS_RegressionCalc function\n\n",
    "created" : 1513048929582.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3802886617",
    "id" : "5A75DF35",
    "lastKnownWriteTime" : 1513106781,
    "last_content_update" : 1513106781490,
    "path" : "Z:/My documents/1packages/ess/R/internal.R",
    "project_path" : "R/internal.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}